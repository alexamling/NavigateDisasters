// This shader simulates abd tracks the progress of fires by manipulating multiple data map inputs

// The fire map stores the current fire state
// The heat map represents the heat generated by the fire and adds to the firemap
// The fuel map is used to alter heat and fire values as burnable material is depleted to the point it no longer supports combustion
// The water map represents the combination of ambient humidity and bodies of water (sourced from the WaterBodyMap)


// Each #kernel tells which function to compile
#pragma kernel LoadBaseMap
#pragma kernel AddFire
#pragma kernel GenerateHeatMap
#pragma kernel GenerateFireMap

// Render textures to store dynamic data
RWTexture2D<float4> FireMap; 
RWTexture2D<float> HeatMap; 
RWTexture2D<float> FuelMap;
RWTexture2D<float> WaterMap;

// textures for static data
Texture2D<float4> FirePattern;
Texture2D<float> HeightMap;
Texture2D<float> WaterBodyMap;
float waterBodyScale;

float4 FireData[32]; // x pos, y pos, scale, intensity
int NumFires;

float2 WindOffset;
float WindStrength;

[numthreads(8,8,1)]
void LoadBaseMap(uint3 id : SV_DispatchThreadID)
{
	uint w, h;
	FirePattern.GetDimensions(w, h);

	float4 Fires = { 0,0,0,0 };

	for (int i = 0; i < NumFires; i++) {
		int3 position = { FireData[i].x * FireData[i].z - (w * .5), FireData[i].y * FireData[i].z - (h * .5), 0};
		Fires = Fires + (FirePattern[(id.xy * FireData[i].z) - position.xy] * FireData[i].w);
	}
	
	FireMap[id.xy] = (Fires + FireMap[id.xy]) *.99;
	WaterMap[id.xy] = saturate(.001 * WaterMap[id.xy] + WaterBodyMap[float2(id.x * waterBodyScale, id.y * waterBodyScale)]);
}

[numthreads(8,8,1)]
void AddFire(uint3 id : SV_DispatchThreadID) {
	uint w, h;
	FirePattern.GetDimensions(w, h);

	int3 position = { FireData[NumFires - 1].x * FireData[NumFires - 1].z - (w * .5), FireData[NumFires - 1].y * FireData[NumFires - 1].z - (h * .5), 0 };
	FireMap[id.xy] += (FirePattern[(id.xy * FireData[NumFires - 1].z) - position.xy] * FireData[NumFires - 1].w);
}

[numthreads(8, 8, 1)]
void GenerateHeatMap(uint3 id : SV_DispatchThreadID)
{
	float baseHeight = 1 - HeightMap[id.xy];

	float heightDif;

	// sample neighboring coordinates, scale based off of the change in heightmap
	float value = FireMap[id.xy];
	heightDif = baseHeight + (HeightMap[float2(id.x, id.y + 1)]);
	value += FireMap[float2(id.x, id.y + 1)] * heightDif * heightDif * heightDif * heightDif * heightDif * heightDif;

	heightDif = baseHeight + (HeightMap[float2(id.x, id.y - 1)]);
	value += FireMap[float2(id.x, id.y - 1)] * heightDif * heightDif * heightDif * heightDif * heightDif * heightDif;

	heightDif = baseHeight + (HeightMap[float2(id.x + 1, id.y)]);
	value += FireMap[float2(id.x + 1, id.y)] * heightDif * heightDif * heightDif * heightDif * heightDif * heightDif;

	heightDif = baseHeight + (HeightMap[float2(id.x - 1, id.y)]);
	value += FireMap[float2(id.x - 1, id.y)] * heightDif * heightDif * heightDif * heightDif * heightDif * heightDif;

	heightDif = baseHeight + (HeightMap[float2(id.x + 1, id.y + 1)]);
	value += FireMap[float2(id.x + 1, id.y + 1)] * heightDif * heightDif * heightDif * heightDif * heightDif * heightDif;

	heightDif = baseHeight + (HeightMap[float2(id.x + 1, id.y - 1)]);
	value += FireMap[float2(id.x + 1, id.y - 1)] * heightDif * heightDif * heightDif * heightDif * heightDif * heightDif;

	heightDif = baseHeight + (HeightMap[float2(id.x - 1, id.y + 1)]);
	value += FireMap[float2(id.x - 1, id.y + 1)] * heightDif * heightDif * heightDif * heightDif * heightDif * heightDif;

	heightDif = baseHeight + (HeightMap[float2(id.x - 1, id.y - 1)]);
	value += FireMap[float2(id.x - 1, id.y - 1)] * heightDif * heightDif * heightDif * heightDif * heightDif * heightDif;
	value *= .002f;

	// TODO: Adjust value based on moisture map
	value -= WaterMap[id.xy] * WaterMap[id.xy];
	WaterMap[id.xy] -= value * .5f;

	// add heat value and adjust for fuelmap
	HeatMap[id.xy] = ((value + HeatMap[id.xy]) * (FuelMap[id.xy])) -.000025;

	// alter fuelmap
	FuelMap[id.xy] -= value * .075 + .001;
}

[numthreads(8, 8, 1)]
void GenerateFireMap(uint3 id : SV_DispatchThreadID)
{
	float value = HeatMap[id.xy] * saturate(.5 - WindStrength);
	value += HeatMap[float2(id.x - WindOffset.x, id.y - WindOffset.y)] * WindStrength; // adjust for wind
	value += FireMap[id.xy];
	value *= FuelMap[id.xy] + .99;
	FireMap[id.xy] = float4(value, value, value, 0);
}
